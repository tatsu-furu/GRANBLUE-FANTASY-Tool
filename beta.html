<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ã‚°ãƒ©ãƒ–ãƒ« ãƒ ãƒ¼ãƒ–è¡¨ä½œæˆãƒ„ãƒ¼ãƒ«</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
</head>
<body>

    <div class="container">
        <h1>ã‚°ãƒ©ãƒ–ãƒ« ãƒ ãƒ¼ãƒ–è¡¨ä½œæˆãƒ„ãƒ¼ãƒ«</h1>

        <div id="setup-phase" style="display: block;">
            <h2>1. ç·¨æˆç™»éŒ² / ä¿å­˜ãƒ­ãƒ¼ãƒ‰</h2>

            <fieldset id="save-load-section">
                <legend>ä¿å­˜ / ãƒ­ãƒ¼ãƒ‰ (ã‚¹ãƒ­ãƒƒãƒˆ)</legend>
                <div>
                    <label for="save-slot-name">ã‚¹ãƒ­ãƒƒãƒˆå</label>
                    <input type="text" id="save-slot-name">
                </div>
                <div>
                    <label for="load-slot-select">ä¿å­˜æ¸ˆã¿ã‚¹ãƒ­ãƒƒãƒˆ</label>
                    <select id="load-slot-select">
                        <option value="">-- ã‚¹ãƒ­ãƒƒãƒˆã‚’é¸æŠ --</option>
                    </select>
                </div>
                <button id="save-btn" class="btn">ç¾åœ¨ã®ç·¨æˆ/ãƒ ãƒ¼ãƒ–ã‚’ä¿å­˜</button>
                <div style="display: flex; gap: 5px;">
                    <button id="load-btn" class="btn" style="flex: 1;">ãƒ­ãƒ¼ãƒ‰</button>
                    <button id="delete-btn" class="btn" style="flex: 1;">å‰Šé™¤</button>
                </div>

                <legend style="margin-top: 15px; grid-column: 1 / -1; text-align: center;">ãƒ•ã‚¡ã‚¤ãƒ«å…±æœ‰ (ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—)</legend>
                <button id="export-btn" class="btn">ç¾åœ¨ã®ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã¸ä¿å­˜ (Export)</button>

                <input type="file" id="import-file-input" accept=".json, text/plain">
                <label for="import-file-input" class="btn import-btn-label">ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰èª­è¾¼ (Import)</label>
            </fieldset>

            <fieldset>
                <legend>ãƒ ãƒ¼ãƒ–å…¨ä½“ãƒ¡ãƒ¢</legend>
                <textarea id="overall-memo-input" placeholder="ãƒ ãƒ¼ãƒ–ã®å‰ææ¡ä»¶ã€è¨ä¼æ™‚é–“ç›®å®‰ã€æ³¨æ„ç‚¹ãªã©..."></textarea>
            </fieldset>

            <fieldset>
                <legend>æ­¦å™¨ç·¨æˆã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ (1æš)</legend>
                <input type="file" id="weapon-image-input" accept="image/*" style="display: none;">
                <div id="weapon-image-upload-area" onclick="document.getElementById('weapon-image-input').click();">
                    <span id="upload-placeholder-text">
                        ã‚¯ãƒªãƒƒã‚¯ã—ã¦ç”»åƒã‚’é¸æŠ (ã¾ãŸã¯ãƒ‰ãƒ©ãƒƒã‚°ï¼†ãƒ‰ãƒ­ãƒƒãƒ—)<br>
                        <span style="font-weight: bold; color: #ffb400;">ã¾ãŸã¯ãƒšãƒ¼ã‚¹ãƒˆ (Ctrl+V)</span><br>
                    </span>
                    <span id="upload-feedback">(æ¨å¥¨: 500KBä»¥ä¸‹ / è‡ªå‹•ãƒªã‚µã‚¤ã‚ºã‚ã‚Š)</span>
                    <img id="weapon-image-preview" src="#" alt="æ­¦å™¨ç·¨æˆãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼">
                </div>
                <button id="clear-weapon-image-btn" class="btn">ç”»åƒã‚’å‰Šé™¤</button>
            </fieldset>

            <fieldset>
                <legend>ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼</legend>
                <div class="input-grid">
                    <div>
                        <label>ã‚µãƒ–äººæ•°</label>
                        <select id="sub-member-count">
                            <option value="2" selected>2äºº (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ)</option>
                            <option value="5">5äºº (ãã®ä»–)</option>
                        </select>
                    </div>
                </div>
                <div class="input-grid" style="margin-top: 10px;">
                    <div><label for="char1">ä¸»äººå…¬</label><input type="text" id="char1" value="ä¸»äººå…¬"></div>
                    <div><label for="char2">ã‚­ãƒ£ãƒ©2</label><input type="text" id="char2" value=""></div>
                    <div><label for="char3">ã‚­ãƒ£ãƒ©3</label><input type="text" id="char3" value=""></div>
                    <div><label for="char4">ã‚­ãƒ£ãƒ©4</label><input type="text" id="char4" value=""></div>
                    <div><label for="char5">ã‚µãƒ–1</label><input type="text" id="char5" value=""></div>
                    <div><label for="char6">ã‚µãƒ–2</label><input type="text" id="char6" value=""></div>

                    <div id="extra-sub-inputs">
                        <div><label for="char7">ã‚µãƒ–3</label><input type="text" id="char7" value=""></div>
                        <div><label for="char8">ã‚µãƒ–4</label><input type="text" id="char8" value=""></div>
                        <div><label for="char9">ã‚µãƒ–5</label><input type="text" id="char9" value=""></div>
                    </div>
                </div>
            </fieldset>

            <fieldset>
                <legend>å¬å–šçŸ³</legend>
                <div class="input-grid">
                    <div><label for="summon-main">ãƒ¡ã‚¤ãƒ³</label><input type="text" id="summon-main" value=""></div>
                    <div><label for="summon-support">ã‚µãƒãƒ¼ã‚¿ãƒ¼</label><input type="text" id="summon-support" value=""></div>
                    <div><label for="summon-sub1">ã‚µãƒ–1</label><input type="text" id="summon-sub1" value=""></div>
                    <div><label for="summon-sub2">ã‚µãƒ–2</label><input type="text" id="summon-sub2" value=""></div>
                    <div><label for="summon-sub3">ã‚µãƒ–3</label><input type="text" id="summon-sub3" value=""></div>
                    <div><label for="summon-sub4">ã‚µãƒ–4</label><input type="text" id="summon-sub4" value=""></div>
                </div>
            </fieldset>

            <button id="setup-complete-btn" class="btn">ãƒ ãƒ¼ãƒ–å…¥åŠ›ç”»é¢ã¸</button>

            <div class="reset-buttons" style="margin-top: 15px;">
                <button id="reset-setup-btn" class="reset-btn btn">ç·¨æˆå…¥åŠ›æ¬„ã®ã¿ã‚¯ãƒªã‚¢</button>
                <button id="clear-all-data-btn" class="btn">å…¨ã‚¹ãƒ­ãƒƒãƒˆå‰Šé™¤ (å®Œå…¨ãƒªã‚»ãƒƒãƒˆ)</button>
            </div>
        </div> <div id="move-phase" style="display: none;">
             <h2>2. ãƒ ãƒ¼ãƒ–å…¥åŠ›</h2>

            <div class="move-grid">
                <div class="action-panel">
                    <div id="turn-counter">TURN 1</div>

                    <div id="branching-controls" style="display: none;">
                        <div id="branching-selector"></div>
                        <div id="branching-status">åˆ†å²Bå…¥åŠ›ä¸­ (2/2)</div>
                        <div id="branching-buttons">
                            <button id="next-branch-btn" class="btn">æ¬¡ã®åˆ†å²ã¸</button>
                            <button id="finish-branching-btn" class="btn">åˆ†å²å…¥åŠ›ã‚’å®Œäº†</button>
                        </div>
                    </div>

                    <div>
                        <strong>ã“ã®ã‚¿ãƒ¼ãƒ³ã®ãƒ¡ãƒ¢:</strong>
                        <textarea id="turn-memo-input" placeholder="HPäºˆå…†ã€æ•µã®è¡Œå‹•ãªã©..."></textarea>
                    </div>

                    <div>
                        <strong>è¡Œå‹•ã‚­ãƒ£ãƒ©é¸æŠ:</strong>
                        <div class="char-select-buttons" id="char-select-container"></div>
                    </div>

                    <div>
                        <strong>ã‚¢ãƒ“ãƒªãƒ†ã‚£:</strong>
                        <div class="action-buttons">
                            <button class="action-btn btn" data-action="1ã‚¢ãƒ“">1ã‚¢ãƒ“</button>
                            <button class="action-btn btn" data-action="2ã‚¢ãƒ“">2ã‚¢ãƒ“</button>
                            <button class="action-btn btn" data-action="3ã‚¢ãƒ“">3ã‚¢ãƒ“</button>
                            <button class="action-btn btn" data-action="4ã‚¢ãƒ“">4ã‚¢ãƒ“</button>
                        </div>
                    </div>

                    <div>
                        <strong>ãã®ä»– (ã‚­ãƒ£ãƒ©åˆ¥):</strong>
                        <div class="action-buttons">
                            <button class="action-btn btn" data-action="ã‚¬ãƒ¼ãƒ‰">ã‚¬ãƒ¼ãƒ‰</button>
                            <button class="action-btn btn attack-btn-on" data-action="ã‚­ãƒ¥ã‚¢ãƒ">ã‚­ãƒ¥ã‚¢ãƒ</button>
                        </div>
                    </div>

                    <div>
                        <strong>å¬å–šçŸ³ (å…¨ä½“):</strong>
                        <div class="summon-buttons" id="summon-buttons-container"></div>
                    </div>

                    <div>
                        <strong>ã‚¢ã‚¤ãƒ†ãƒ  (å…¨ä½“):</strong>
                        <div class="action-buttons">
                            <button class="action-btn btn attack-btn-on" data-action="ã‚ªãƒ¼ãƒ«ãƒãƒ¼ã‚·ãƒ§ãƒ³">ã‚ªãƒ¼ãƒ«ãƒãƒ¼ã‚·ãƒ§ãƒ³</button>
                             <button class="action-btn btn attack-btn-on" data-action="FC">FC</button>
                        </div>
                    </div>

                    <div>
                        <strong>ã‚¿ãƒ¼ãƒ³çµ‚äº†:</strong>
                        <div class="action-buttons">
                            <button class="action-btn attack-btn-off btn" data-action="æ”»æ’ƒ (å¥¥ç¾©OFF)">æ”»æ’ƒ (å¥¥ç¾©OFF)</button>
                            <button class="action-btn attack-btn-on btn" data-action="æ”»æ’ƒ (å¥¥ç¾©ON)">æ”»æ’ƒ (å¥¥ç¾©ON)</button>
                        </div>
                    </div>

                <!-- ãƒœã‚¿ãƒ³ç¾¤ã¯å±¥æ­´ã®ä¸Šä¸‹ã«ç§»å‹•ã—ã¾ã—ãŸ -->
                </div> <div>
                    <div id="mode-toggle-area">
                        <button id="goto-playback-btn" class="btn">å†ç”Ÿãƒ¢ãƒ¼ãƒ‰ã¸ â–¶</button>
                    </div>

                    <div class="history-panel">
                        <strong>è¡Œå‹•å±¥æ­´ (ãƒ ãƒ¼ãƒ–è¡¨)</strong>
                        <!-- ä¸Šéƒ¨ï¼šåˆ†å²ä½œæˆ ã¨ ä¸Šæ›¸ãä¿å­˜ï¼ˆå…ƒIDã‚’ä½¿ã£ã¦ç›´æ¥ãƒãƒ³ãƒ‰ãƒ©ã«æ¥ç¶šï¼‰ -->
                        <div class="history-controls" style="margin:6px 0; display:flex; gap:6px; flex-wrap:wrap;">
                            <button id="start-branching-btn" class="btn" style="background-color: #afa84ccc;">ã“ã®ã‚¿ãƒ¼ãƒ³ã«åˆ†å²ã‚’ä½œæˆ</button>
                            <button id="overwrite-save-btn" class="btn" style="background-color: #4CAF50;">ç¾åœ¨ã®ã‚¹ãƒ­ãƒƒãƒˆã«ä¸Šæ›¸ãä¿å­˜</button>
                        </div>
                        <div id="new-history-view" style="height: 400px; overflow-y: auto; border: 1px solid #555; padding: 10px; background-color: #111; font-family: 'SFMono-Regular', Consolas, monospace; color: #b0c4de;">
                             {/* JSã§å±¥æ­´ãŒæç”»ã•ã‚Œã‚‹ */}
                         </div>
                        <!-- ä¸‹éƒ¨ï¼šæˆ»ã‚‹ï¼ˆUndoï¼‰ã€å±¥æ­´ãƒªã‚»ãƒƒãƒˆã€ç·¨æˆç”»é¢ã«æˆ»ã‚‹ï¼ˆå…ƒIDã‚’ä½¿ã£ã¦ç›´æ¥ãƒãƒ³ãƒ‰ãƒ©ã«æ¥ç¶šï¼‰ -->
                        <div class="history-controls" style="margin:6px 0; display:flex; gap:6px; flex-wrap:wrap;">
                            <button id="undo-last-action-btn" class="reset-btn btn">1ã¤å‰ã®æ“ä½œã«æˆ»ã‚‹ (Undo)</button>
                            <button id="move-reset-btn" class="reset-btn btn">ãƒ ãƒ¼ãƒ–å±¥æ­´ã ã‘ãƒªã‚»ãƒƒãƒˆ</button>
                            <button id="back-to-setup-btn" class="reset-btn btn">ç·¨æˆç™»éŒ²/ãƒ­ãƒ¼ãƒ‰ç”»é¢ã«æˆ»ã‚‹</button>
                        </div>
                        <div id="export-area">
                            <span id="copy-feedback"></span>
                        </div>
                    </div>

                    <div class="playback-panel">
                        <strong>å†ç”Ÿãƒ¢ãƒ¼ãƒ‰ (ã‚«ãƒ³ãƒš)</strong>
                        <div id="playback-area">
                        </div>
                        <div id="playback-nav">
                            <button id="playback-prev-btn" class="btn">&lt; å‰ã®ã‚¿ãƒ¼ãƒ³</button>
                            <span id="playback-nav-center">TURN 1 / 1</span>
                            <button id="playback-next-btn" class="btn">æ¬¡ã®ã‚¿ãƒ¼ãƒ³ &gt;</button>
                        </div>
                        <div style="margin-top: 10px; text-align: center;">
                             <button id="save-playback-image-btn" class="btn">ãƒ ãƒ¼ãƒ–è¡¨ã‚’ç”»åƒã§ä¿å­˜</button>
                             <button id="back-to-edit-btn" class="reset-btn btn" style="margin-top: 5px;">ç·¨é›†ãƒ¢ãƒ¼ãƒ‰ã«æˆ»ã‚‹</button>
                        </div>
                    </div>
                </div> </div> </div> </div> <script>
        // --- å®šæ•°ãƒ»å¤‰æ•° ---
        const STORAGE_KEY_SLOTS = 'gbfMoveMakerV5_slots';
        const STORAGE_KEY_PREFIX = 'gbfMoveMakerV5_slot_';
        const STORAGE_KEY_CURRENT = 'gbfMoveMakerV5_currentWork_V23'; // ãƒ‡ãƒ¼ã‚¿æ§‹é€ å¤‰æ›´ã®ãŸã‚ã‚­ãƒ¼ç¶­æŒ
        const MAX_IMAGE_WIDTH = 1200;
        const IMAGE_QUALITY = 0.7;

        // ãƒ‡ãƒ¼ã‚¿æ§‹é€ å®šç¾©
        const getDefaultWorkData = () => ({
            setup: { characters: ["ä¸»äººå…¬", "", "", "", "", "", "", "", ""], summons: ["", "", "", "", "", ""], subCount: 2, overallMemo: "", weaponImageBase64: null },
            state: { currentTurn: 1, selectedCharIndex: 0, turns: [ { turnNumber: 1, branches: [ { actions: [], memo: "" } ] } ], isBranchingMode: false, currentBranchIndex: 0, totalBranchesInTurn: 1 },
            slotName: ""
        });
        let currentWorkData = getDefaultWorkData();
        let savedSlotNames = [];
        let currentPlaybackTurn = 1;
        let totalPlaybackTurns = 1;
        // Undo ç”¨å±¥æ­´ã‚¹ã‚¿ãƒƒã‚¯ï¼ˆstate ã®ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆã‚’ä¿å­˜ï¼‰
        let stateHistory = [];

        // structuredClone ãŒä½¿ãˆãªã„ç’°å¢ƒå‘ã‘ã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
        function structuredCloneSafe(obj) {
            if (typeof structuredClone === 'function') return structuredClone(obj);
            return JSON.parse(JSON.stringify(obj));
        }

        // æ“ä½œå‰ã«å‘¼ã‚“ã§ç¾åœ¨ã® state ã‚’å±¥æ­´ã«ä¿å­˜ã™ã‚‹
        function saveStateForUndo() {
            try {
                stateHistory.push(structuredCloneSafe(currentWorkData.state));
                // å±¥æ­´ãŒå¢—ãˆã™ãã‚‹å ´åˆã¯ä¸Šé™ã‚’è¨­ã‘ã—ã¦ã‚‚è‰¯ã„ï¼ˆä¾‹: 200 ä»¶ï¼‰
                if (stateHistory.length > 1000) stateHistory.shift();
            } catch (e) {
                console.warn('Undo: state snapshot failed', e);
            }
        }

        // --- DOMè¦ç´ ã®å–å¾— ---
        const setupPhase = document.getElementById('setup-phase');
        const movePhase = document.getElementById('move-phase');
        const setupCompleteBtn = document.getElementById('setup-complete-btn');
        const charInputs = Array.from({length: 9}, (_, i) => document.getElementById(`char${i + 1}`));
        const summonInputs = [document.getElementById('summon-main'), document.getElementById('summon-support'), document.getElementById('summon-sub1'), document.getElementById('summon-sub2'), document.getElementById('summon-sub3'), document.getElementById('summon-sub4') ];
        const subMemberCountSelect = document.getElementById('sub-member-count');
        const extraSubInputs = document.getElementById('extra-sub-inputs');
        const saveSlotNameInput = document.getElementById('save-slot-name');
        const loadSlotSelect = document.getElementById('load-slot-select');
        const saveBtn = document.getElementById('save-btn');
        const loadBtn = document.getElementById('load-btn');
        const deleteBtn = document.getElementById('delete-btn');
        const clearAllDataBtn = document.getElementById('clear-all-data-btn');
        const exportBtn = document.getElementById('export-btn');
        const importFileInput = document.getElementById('import-file-input');
        const resetSetupBtn = document.getElementById('reset-setup-btn');
        const overwriteSaveBtn = document.getElementById('overwrite-save-btn');
        const undoLastActionBtn = document.getElementById('undo-last-action-btn');
        const overallMemoInput = document.getElementById('overall-memo-input');
        const weaponImageInput = document.getElementById('weapon-image-input');
        const weaponImageUploadArea = document.getElementById('weapon-image-upload-area');
        const weaponImagePreview = document.getElementById('weapon-image-preview');
        const clearWeaponImageBtn = document.getElementById('clear-weapon-image-btn');
        const uploadFeedback = document.getElementById('upload-feedback');
        const uploadPlaceholderText = document.getElementById('upload-placeholder-text');
        const turnCounter = document.getElementById('turn-counter');
        const turnMemoInput = document.getElementById('turn-memo-input');
        const charSelectContainer = document.getElementById('char-select-container');
        const actionButtons = document.querySelectorAll('.action-btn');
        const summonButtonsContainer = document.getElementById('summon-buttons-container');
        const newHistoryView = document.getElementById('new-history-view');
        const moveResetBtn = document.getElementById('move-reset-btn');
        const backToSetupBtn = document.getElementById('back-to-setup-btn');
        const copyFeedback = document.getElementById('copy-feedback');
        const gotoPlaybackBtn = document.getElementById('goto-playback-btn');
        const playbackArea = document.getElementById('playback-area');
        const playbackPrevBtn = document.getElementById('playback-prev-btn');
        const playbackNextBtn = document.getElementById('playback-next-btn');
        const playbackNavCenter = document.getElementById('playback-nav-center');
        const backToEditBtn = document.getElementById('back-to-edit-btn');
        const savePlaybackImageBtn = document.getElementById('save-playback-image-btn');
        const branchingControls = document.getElementById('branching-controls');
        const branchingStatus = document.getElementById('branching-status');
        const startBranchingBtn = document.getElementById('start-branching-btn');
        const nextBranchBtn = document.getElementById('next-branch-btn');
        const finishBranchingBtn = document.getElementById('finish-branching-btn');
        const branchingSelector = document.getElementById('branching-selector');

        // NOTE: duplicate-control forwarding removed; buttons moved to history area with original IDs

        // --- ãƒ‡ãƒ¼ã‚¿ä¿å­˜/ãƒ­ãƒ¼ãƒ‰é–¢æ•° ---
        function saveCurrentWork() {
             currentWorkData.setup.characters = charInputs.map(input => input.value);
             currentWorkData.setup.summons = summonInputs.map(input => input.value);
             currentWorkData.setup.subCount = parseInt(subMemberCountSelect.value, 10);
             currentWorkData.setup.overallMemo = overallMemoInput.value;
             if (movePhase.style.display === 'block' && !movePhase.classList.contains('playback-mode')) {
                 const currentTurnData = getCurrentTurnData(false);
                 if (currentTurnData && currentTurnData.branches[currentWorkData.state.currentBranchIndex]) {
                     currentTurnData.branches[currentWorkData.state.currentBranchIndex].memo = turnMemoInput.value;
                 }
             }
             localStorage.setItem(STORAGE_KEY_CURRENT, JSON.stringify(currentWorkData));
             // console.log("Saved:", JSON.stringify(currentWorkData)); // Debug
        }
        function loadCurrentWork() {
             const loadedData = localStorage.getItem(STORAGE_KEY_CURRENT);
             if (loadedData) {
                try {
                    const parsedData = JSON.parse(loadedData);
                    if (parsedData && parsedData.setup && parsedData.state && Array.isArray(parsedData.state.turns)) {
                        // import æ™‚ç‚¹ã§ undo å±¥æ­´ã¯ã‚¯ãƒªã‚¢
                        stateHistory = [];
                         currentWorkData = parsedData;
                         if (currentWorkData.state.isBranchingMode === undefined) currentWorkData.state.isBranchingMode = false;
                         if (currentWorkData.state.currentBranchIndex === undefined) currentWorkData.state.currentBranchIndex = 0;
                         if (currentWorkData.state.totalBranchesInTurn === undefined) currentWorkData.state.totalBranchesInTurn = 1;
                         if (!currentWorkData.setup.overallMemo) currentWorkData.setup.overallMemo = "";
                         if (!currentWorkData.setup.weaponImageBase64) currentWorkData.setup.weaponImageBase64 = null;
                         currentWorkData.state.turns.forEach(turn => {
                            if (!turn.branches) turn.branches = [{ actions: [], memo: "" }];
                            turn.branches.forEach(branch => { if (branch.memo === undefined) branch.memo = ""; });
                         });
                         if (currentWorkData.state.currentTurn < 1) currentWorkData.state.currentTurn = 1;
                         if (currentWorkData.state.currentTurn > currentWorkData.state.turns.length) {
                             currentWorkData.state.currentTurn = currentWorkData.state.turns.length > 0 ? currentWorkData.state.turns.length : 1;
                         }
                         const currentTurnData = getCurrentTurnData(false);
                         if (currentTurnData && currentWorkData.state.currentBranchIndex >= currentTurnData.branches.length) {
                             currentWorkData.state.currentBranchIndex = 0;
                         }
                     } else { currentWorkData = getDefaultWorkData(); console.warn("Loaded data structure invalid. Resetting."); }
                 } catch (e) { console.error("Data load/parse failed:", e); currentWorkData = getDefaultWorkData(); }
           } else { currentWorkData = getDefaultWorkData(); }
          // load æ™‚ç‚¹ã§ undo å±¥æ­´ã¯ãƒªã‚»ãƒƒãƒˆ
          stateHistory = [];
        }
        function loadSlotNames() {
            const loadedData = localStorage.getItem(STORAGE_KEY_SLOTS); savedSlotNames = loadedData ? JSON.parse(loadedData) : [];
            loadSlotSelect.innerHTML = '<option value="">-- ã‚¹ãƒ­ãƒƒãƒˆã‚’é¸æŠ --</option>';
            savedSlotNames.forEach(name => { const option = document.createElement('option'); option.value = name; option.textContent = name; loadSlotSelect.appendChild(option); });
        }
        function saveSlotNames() {
            localStorage.setItem(STORAGE_KEY_SLOTS, JSON.stringify(savedSlotNames));
        }
        function loadSetupDataToDOM() {
            charInputs.forEach((input, index) => input.value = currentWorkData.setup.characters[index] || '');
            summonInputs.forEach((input, index) => input.value = currentWorkData.setup.summons[index] || '');
            subMemberCountSelect.value = currentWorkData.setup.subCount;
            toggleExtraSubInputs(currentWorkData.setup.subCount);
            saveSlotNameInput.value = currentWorkData.slotName;
            overallMemoInput.value = currentWorkData.setup.overallMemo;
            updateImagePreview(currentWorkData.setup.weaponImageBase64);
        }
        function loadStateDataToDOM() {
            const state = currentWorkData.state;
            turnCounter.textContent = `TURN ${state.currentTurn}`;
            const currentTurnData = getCurrentTurnData(false);
            if (currentTurnData && currentTurnData.branches.length > state.currentBranchIndex && currentTurnData.branches[state.currentBranchIndex]) {
                 turnMemoInput.value = currentTurnData.branches[state.currentBranchIndex].memo || '';
            } else { turnMemoInput.value = ''; }
            renderHistoryView();
            updateBranchingUI();
        }
        function toggleExtraSubInputs(count) {
            extraSubInputs.style.display = (count === 5) ? 'grid' : 'none';
        }
        function getCurrentTurnData(createIfNeeded = true) {
            const turnIndex = currentWorkData.state.currentTurn - 1;
            if (createIfNeeded && turnIndex >= currentWorkData.state.turns.length) {
                for (let i = currentWorkData.state.turns.length; i <= turnIndex; i++) {
                     currentWorkData.state.turns.push({ turnNumber: i + 1, branches: [{ actions: [], memo: "" }] });
                }
            }
            return currentWorkData.state.turns[turnIndex] || null;
        }

        // --- ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ ---
        setupCompleteBtn.addEventListener('click', () => { console.log("Move Phase Button Clicked"); saveCurrentWork(); goToMovePhase(); }); // V25 Log
        charInputs.forEach(input => input.addEventListener('input', saveCurrentWork));
        summonInputs.forEach(input => input.addEventListener('input', saveCurrentWork));
        subMemberCountSelect.addEventListener('change', (e) => { toggleExtraSubInputs(parseInt(e.target.value, 10)); saveCurrentWork(); });
        turnMemoInput.addEventListener('input', () => { saveCurrentWork(); });
        saveBtn.addEventListener('click', () => { saveCurrentWork(); const slotName = saveSlotNameInput.value; if (!slotName) { alert('ã‚¹ãƒ­ãƒƒãƒˆåã‚’å…¥åŠ›'); return; } currentWorkData.slotName = slotName; localStorage.setItem(STORAGE_KEY_PREFIX + slotName, JSON.stringify(currentWorkData)); if (!savedSlotNames.includes(slotName)) { savedSlotNames.push(slotName); saveSlotNames(); loadSlotNames(); } alert(`ã€Œ${slotName}ã€ã¨ã—ã¦ä¿å­˜`); });
        loadBtn.addEventListener('click', () => { const slotName = loadSlotSelect.value; if (!slotName) { alert('ã‚¹ãƒ­ãƒƒãƒˆé¸æŠ'); return; } const loadedData = localStorage.getItem(STORAGE_KEY_PREFIX + slotName); if (loadedData) { currentWorkData = getDefaultWorkData(); loadCurrentWork(); saveCurrentWork(); loadSetupDataToDOM(); loadStateDataToDOM(); alert(`ã€Œ${slotName}ã€ã‚’ãƒ­ãƒ¼ãƒ‰`); } else { alert('ãƒ­ãƒ¼ãƒ‰å¤±æ•—'); } });
        deleteBtn.addEventListener('click', () => { const slotName = loadSlotSelect.value; if (!slotName) return; if (confirm(`ã€Œ${slotName}ã€å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ`)) { localStorage.removeItem(STORAGE_KEY_PREFIX + slotName); savedSlotNames = savedSlotNames.filter(name => name !== slotName); saveSlotNames(); loadSlotNames(); alert(`ã€Œ${slotName}ã€å‰Šé™¤`); } });
        actionButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                // æ“ä½œå‰ã® state ã‚’å±¥æ­´ã«ä¿å­˜ã—ã¦ãŠã
                saveStateForUndo();
                const action = btn.dataset.action;
                const charIndex = currentWorkData.state.selectedCharIndex;
                const charName = currentWorkData.setup.characters[charIndex] || `ã‚­ãƒ£ãƒ©${charIndex + 1}`;
                const state = currentWorkData.state;
                if (action.startsWith('æ”»æ’ƒ')) {
                    saveCurrentWork(); logAction(`[${action}]`);
                    if (state.isBranchingMode) { saveCurrentWork(); }
                    else {
                        state.currentTurn++; turnCounter.textContent = `TURN ${state.currentTurn}`;
                        getCurrentTurnData(); renderHistoryView();
                        const nextTurnData = getCurrentTurnData(false);
                        turnMemoInput.value = nextTurnData?.branches[0]?.memo || '';
                        saveCurrentWork();
                    }
                } else if (action === 'ã‚ªãƒ¼ãƒ«ãƒãƒ¼ã‚·ãƒ§ãƒ³' || action === 'FC') {
                    logAction(`[${action}]`);
                } else {
                    logAction(`[${charName}] ${action}`);
                }
            });
        });
        moveResetBtn.addEventListener('click', () => { if (confirm('å±¥æ­´ãƒªã‚»ãƒƒãƒˆï¼Ÿ')) { // ãƒªã‚»ãƒƒãƒˆå‰ã®ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆ
            saveStateForUndo();
            const defaultState = getDefaultWorkData().state; currentWorkData.state.currentTurn = defaultState.currentTurn; currentWorkData.state.selectedCharIndex = defaultState.selectedCharIndex; currentWorkData.state.turns = JSON.parse(JSON.stringify(defaultState.turns)); currentWorkData.state.isBranchingMode = false; currentWorkData.state.currentBranchIndex = 0; currentWorkData.state.totalBranchesInTurn = 1; saveCurrentWork(); loadStateDataToDOM(); selectCharacter(0, true); alert('å±¥æ­´ãƒªã‚»ãƒƒãƒˆå®Œäº†'); } });
        backToSetupBtn.addEventListener('click', () => { saveCurrentWork(); goToSetupPhase(); });
        clearAllDataBtn.addEventListener('click', () => { if (confirm('å…¨ãƒ‡ãƒ¼ã‚¿å‰Šé™¤ï¼Ÿ')) { savedSlotNames.forEach(name => { localStorage.removeItem(STORAGE_KEY_PREFIX + name); }); localStorage.removeItem(STORAGE_KEY_SLOTS); localStorage.removeItem(STORAGE_KEY_CURRENT); location.reload(); } });
    exportBtn.addEventListener('click', () => { saveCurrentWork(); const jsonString = JSON.stringify(currentWorkData, null, 2); const blob = new Blob([jsonString], {type: 'application/json'}); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; let fileName = currentWorkData.slotName || 'gbf-move-data'; a.download = fileName.endsWith('.json') ? fileName : fileName + '.json'; a.click(); URL.revokeObjectURL(url); a.remove(); });
    importFileInput.addEventListener('change', (event) => { const file = event.target.files[0]; if (!file) return; const reader = new FileReader(); reader.onload = (e) => { try { currentWorkData = getDefaultWorkData(); const json = JSON.parse(e.target.result); if (json && json.setup && json.state && Array.isArray(json.state.turns)) { currentWorkData.setup = {...currentWorkData.setup, ...json.setup}; currentWorkData.state = {...currentWorkData.state, ...json.state}; currentWorkData.slotName = json.slotName || ""; if (!currentWorkData.state.isBranchingMode) currentWorkData.state.isBranchingMode = false; if (!currentWorkData.state.currentBranchIndex) currentWorkData.state.currentBranchIndex = 0; if (!currentWorkData.state.totalBranchesInTurn) currentWorkData.state.totalBranchesInTurn = 1; currentWorkData.state.turns.forEach(turn => { if (!turn.branches) turn.branches = [{ actions: [], memo: "" }]; turn.branches.forEach(branch => { if (branch.memo === undefined) branch.memo = ""; }); });
            // ã‚¤ãƒ³ãƒãƒ¼ãƒˆå¾Œã¯ undo å±¥æ­´ã‚’ã‚¯ãƒªã‚¢
            saveCurrentWork(); stateHistory = [];
            loadSetupDataToDOM(); loadStateDataToDOM(); alert(`ã€Œ${file.name}ã€ãƒ­ãƒ¼ãƒ‰å®Œäº†`); goToSetupPhase(); } else { alert('ã‚¨ãƒ©ãƒ¼: ç„¡åŠ¹å½¢å¼'); } } catch (error) { console.error('Import Error:', error); alert('ã‚¨ãƒ©ãƒ¼: èª­è¾¼å¤±æ•—'); } event.target.value = null; }; reader.onerror = () => { alert('ã‚¨ãƒ©ãƒ¼: èª­è¾¼å¤±æ•—'); event.target.value = null; }; reader.readAsText(file); });
        resetSetupBtn.addEventListener('click', () => { if (confirm('ç·¨æˆå…¥åŠ›ã‚¯ãƒªã‚¢ï¼Ÿ')) { currentWorkData.setup = getDefaultWorkData().setup; saveCurrentWork(); loadSetupDataToDOM(); alert('ã‚¯ãƒªã‚¢å®Œäº†'); } });
        overwriteSaveBtn.addEventListener('click', () => { saveCurrentWork(); const currentSlotName = currentWorkData.slotName; if (currentSlotName) { localStorage.setItem(STORAGE_KEY_PREFIX + currentSlotName, JSON.stringify(currentWorkData)); alert(`ã€Œ${currentSlotName}ã€ä¸Šæ›¸ãä¿å­˜`); } else { alert('ã‚¨ãƒ©ãƒ¼: ã‚¹ãƒ­ãƒƒãƒˆåãªã—'); } });
        undoLastActionBtn.addEventListener('click', () => {
            // ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆæ–¹å¼ã® Undo ã‚’å„ªå…ˆ
            try {
                if (stateHistory.length > 0) {
                    const prevState = stateHistory.pop();
                    currentWorkData.state = prevState;
                    renderHistoryView();
                    loadStateDataToDOM();
                    saveCurrentWork();
                    return;
                }
            } catch (e) { console.warn('Undo restore failed', e); }

            // å±¥æ­´ãŒç©ºã®å ´åˆã¯äº’æ›çš„ã«å¾“æ¥ãƒ­ã‚¸ãƒƒã‚¯ã§å¯¾å¿œ
            const currentTurnData = getCurrentTurnData(false);
            if (!currentTurnData) { alert('ã“ã‚Œä»¥ä¸Šæˆ»ã‚Œã¾ã›ã‚“ã€‚'); return; }
            const branchIndex = currentWorkData.state.currentBranchIndex;
            const currentBranch = currentTurnData.branches[branchIndex];
            if (currentBranch && currentBranch.actions.length > 0) {
                // ç¾åœ¨ã®ã‚¿ãƒ¼ãƒ³ã«è¡Œå‹•ãŒã‚ã‚‹ â†’ æœ€å¾Œã®è¡Œå‹•ã‚’å‰Šé™¤
                currentBranch.actions.pop();
                renderHistoryView();
                saveCurrentWork();
                return;
            }

            // ç¾åœ¨ã‚¿ãƒ¼ãƒ³ã«è¡Œå‹•ãªã— â†’ å‰ã®ã‚¿ãƒ¼ãƒ³ã¸
            if (currentWorkData.state.currentTurn > 1) {
                // å‰ã‚¿ãƒ¼ãƒ³ç§»å‹•ã‚‚ undo ã§ãã‚‹ã‚ˆã†ã€ç§»å‹•å‰ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆã¯æ—¢ã«å­˜åœ¨ã—ãªã„æƒ³å®šã®ãŸã‚ã“ã“ã§ä¿å­˜ã—ã¦ãŠã
                // ï¼ˆå¿…è¦ã§ã‚ã‚Œã°ã“ã®è¡Œã¯çœç•¥ã—ã¦ã‚‚æ§‹ã‚ãªã„ï¼‰
                // saveStateForUndo();
                currentWorkData.state.currentTurn -= 1;
                const prevTurnData = getCurrentTurnData(false);
                if (prevTurnData) {
                    currentWorkData.state.currentBranchIndex = Math.max(0, prevTurnData.branches.length - 1);
                } else {
                    currentWorkData.state.currentBranchIndex = 0;
                }
                renderHistoryView();
                loadStateDataToDOM();
                saveCurrentWork();
                console.log("UNDO: moved back to previous turn");
                return;
            }

            alert("ã“ã‚Œä»¥ä¸Šæˆ»ã‚Œã¾ã›ã‚“ã€‚");
            });

        overallMemoInput.addEventListener('input', saveCurrentWork);
        weaponImageInput.addEventListener('change', handleImageUpload);
        clearWeaponImageBtn.addEventListener('click', () => { currentWorkData.setup.weaponImageBase64 = null; updateImagePreview(null); saveCurrentWork(); weaponImageInput.value = null; });
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => { weaponImageUploadArea.addEventListener(eventName, preventDefaults, false); });
        ['dragenter', 'dragover'].forEach(eventName => { weaponImageUploadArea.addEventListener(eventName, () => weaponImageUploadArea.classList.add('highlight'), false); });
        ['dragleave', 'drop'].forEach(eventName => { weaponImageUploadArea.addEventListener(eventName, () => weaponImageUploadArea.classList.remove('highlight'), false); });
        weaponImageUploadArea.addEventListener('drop', handleImageDrop, false);
        gotoPlaybackBtn.addEventListener('click', () => { saveCurrentWork(); movePhase.classList.add('playback-mode'); buildPlaybackView(); });
        backToEditBtn.addEventListener('click', () => { movePhase.classList.remove('playback-mode'); loadStateDataToDOM(); });
        playbackNextBtn.addEventListener('click', () => { if (currentPlaybackTurn < totalPlaybackTurns) { currentPlaybackTurn++; updatePlaybackHighlight(); } });
        playbackPrevBtn.addEventListener('click', () => { if (currentPlaybackTurn > 1) { currentPlaybackTurn--; updatePlaybackHighlight(); } });
        savePlaybackImageBtn.addEventListener('click', async () => { const targetElement = playbackArea; const originalHeight = targetElement.style.height; const originalOverflow = targetElement.style.overflowY; savePlaybackImageBtn.disabled = true; savePlaybackImageBtn.textContent = 'ç”»åƒç”Ÿæˆä¸­...'; try { targetElement.style.height = 'auto'; targetElement.style.overflowY = 'visible'; await new Promise(resolve => setTimeout(resolve, 100)); const canvas = await html2canvas(targetElement, { backgroundColor: '#262930', useCORS: true, scrollX: 0, scrollY: 0, windowWidth: targetElement.offsetWidth, windowHeight: targetElement.offsetHeight }); const imageDataUrl = canvas.toDataURL('image/png'); const a = document.createElement('a'); a.href = imageDataUrl; let fileName = currentWorkData.slotName || 'gbf-move-playback'; a.download = fileName.endsWith('.png') ? fileName : fileName + '.png'; a.click(); a.remove(); } catch (error) { console.error('ç”»åƒä¿å­˜ã‚¨ãƒ©ãƒ¼:', error); alert('ç”»åƒä¿å­˜å¤±æ•—'); } finally { targetElement.style.height = originalHeight; targetElement.style.overflowY = originalOverflow; savePlaybackImageBtn.disabled = false; savePlaybackImageBtn.textContent = 'ãƒ ãƒ¼ãƒ–è¡¨ã‚’ç”»åƒã§ä¿å­˜'; } });
        document.addEventListener('paste', handlePaste);

        // V24: åˆ†å²ãƒœã‚¿ãƒ³ãƒªã‚¹ãƒŠãƒ¼
        startBranchingBtn.addEventListener('click', () => { if (currentWorkData.state.isBranchingMode) return; const currentTurnData = getCurrentTurnData(); if (currentTurnData.branches.length > 1) { alert('æ—¢ã«åˆ†å²ã‚ã‚Š'); return; } const numBranchesInput = prompt("åˆ†å²æ•° (2 or 3):", "2"); let numBranches = parseInt(numBranchesInput, 10); if (isNaN(numBranches) || numBranches < 2 || numBranches > 3) { numBranches = 2; } // å¤‰æ›´å‰ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆ
            saveStateForUndo();
            currentWorkData.state.isBranchingMode = true; currentWorkData.state.currentBranchIndex = 0; currentWorkData.state.totalBranchesInTurn = numBranches; while(currentTurnData.branches.length < numBranches) { currentTurnData.branches.push({ actions: [], memo: "" }); } updateBranchingUI(); renderHistoryView(); saveCurrentWork(); turnMemoInput.value = currentTurnData.branches[0].memo || ''; });
    nextBranchBtn.addEventListener('click', () => { if (!currentWorkData.state.isBranchingMode) return; saveStateForUndo(); saveCurrentWork(); if (currentWorkData.state.currentBranchIndex < currentWorkData.state.totalBranchesInTurn - 1) { currentWorkData.state.currentBranchIndex++; turnMemoInput.value = getCurrentTurnData().branches[currentWorkData.state.currentBranchIndex]?.memo || ''; updateBranchingUI(); renderHistoryView(); saveCurrentWork(); } else { alert('æœ€å¾Œã®åˆ†å²'); } });
    finishBranchingBtn.addEventListener('click', () => { 
        if (!currentWorkData.state.isBranchingMode) return; 
        // åˆ†å²å®Œäº†ã¯ undo å¯¾è±¡
        saveStateForUndo();
        saveCurrentWork();
        finishBranchingMode();
        // åˆ†å²å…¥åŠ›å®Œäº†å¾Œã«æ¬¡ã®ã‚¿ãƒ¼ãƒ³ã¸é€²ã‚€
        advanceTurn();
        saveCurrentWork();
    });

        function preventDefaults(e) { e.preventDefault(); e.stopPropagation(); }
        function handleImageDrop(e) { const dt = e.dataTransfer; const file = dt.files[0]; if (file && file.type.startsWith('image/')) { handleImageFile(file); } else { alert('ç”»åƒé¸æŠ'); } }
        function handleImageUpload(event) { const file = event.target.files[0]; if (file) { handleImageFile(file); } }
        function handlePaste(event) { const targetTagName = event.target.tagName.toLowerCase(); if (targetTagName === 'input' || targetTagName === 'textarea') { return; } const items = event.clipboardData?.items; if (!items) return; processClipboardItems(items, event); }
        async function processClipboardItems(items, event = null) { for (let i = 0; i < items.length; i++) { const item = items[i]; const imageTypes = item.types?.filter(type => type.startsWith("image/")); if (imageTypes?.length > 0) { try { const blob = await item.getType(imageTypes[0]); if (blob) { handleBlobAsFile(blob, event); return; } } catch (err) { console.warn("item.getType() Error:", err); } } if (typeof item.getAsFile === 'function' && item.type.startsWith('image/')) { const blob = item.getAsFile(); if (blob) { handleBlobAsFile(blob, event); return; } } } }
        function handleBlobAsFile(blob, event = null) { if (event) { event.preventDefault(); } const fileName = `pasted_image.${blob.type.split('/')[1] || 'png'}`; const file = new File([blob], fileName, { type: blob.type }); handleImageFile(file); }
        function handleImageFile(file) { const reader = new FileReader(); reader.onload = (e) => { const img = new Image(); img.onload = () => { let canvas = document.createElement('canvas'); let ctx = canvas.getContext('2d'); let width = img.width; let height = img.height; if (width > MAX_IMAGE_WIDTH) { height *= MAX_IMAGE_WIDTH / width; width = MAX_IMAGE_WIDTH; } canvas.width = width; canvas.height = height; ctx.drawImage(img, 0, 0, width, height); const base64String = canvas.toDataURL('image/jpeg', IMAGE_QUALITY); currentWorkData.setup.weaponImageBase64 = base64String; updateImagePreview(base64String); saveCurrentWork(); const originalSizeMB = (file.size / 1024 / 1024).toFixed(2); const compressedSizeKB = (base64String.length * 0.75 / 1024).toFixed(0); uploadFeedback.textContent = `(å…ƒ:${originalSizeMB}MB â†’ åœ§ç¸®å¾Œ ç´„${compressedSizeKB}KB)`; }; img.onerror = () => { alert('ç”»åƒèª­è¾¼å¤±æ•—'); }; img.src = e.target.result; }; reader.onerror = () => { alert('ãƒ•ã‚¡ã‚¤ãƒ«èª­è¾¼å¤±æ•—'); }; reader.readAsDataURL(file); }
        function updateImagePreview(base64String) { if (base64String) { weaponImagePreview.src = base64String; weaponImagePreview.style.display = 'block'; clearWeaponImageBtn.style.display = 'inline-block'; if (uploadPlaceholderText) { uploadPlaceholderText.style.display = 'none'; } } else { weaponImagePreview.src = '#'; weaponImagePreview.style.display = 'none'; clearWeaponImageBtn.style.display = 'none'; if (uploadPlaceholderText) { uploadPlaceholderText.style.display = ''; } uploadFeedback.textContent = "(æ¨å¥¨: 500KBä»¥ä¸‹ / è‡ªå‹•ãƒªã‚µã‚¤ã‚ºã‚ã‚Š)"; } }
        function showCopyFeedback(message, success) { copyFeedback.textContent = message; copyFeedback.className = success ? 'feedback-success' : 'feedback-error'; setTimeout(() => { copyFeedback.textContent = ''; copyFeedback.className = ''; }, 2000); }

        // --- å†…éƒ¨é–¢æ•° ---
        function logAction(actionText) {
            const currentTurnData = getCurrentTurnData();
            if (currentTurnData && currentTurnData.branches[currentWorkData.state.currentBranchIndex]) {
                 currentTurnData.branches[currentWorkData.state.currentBranchIndex].actions.push(actionText);
                 renderHistoryView(); saveCurrentWork();
            } else { console.error("Error logging action."); }
        }
        function renderHistoryView() {
             newHistoryView.innerHTML = '';
             currentWorkData.state.turns.forEach(turn => {
                 const turnDiv = document.createElement('div'); turnDiv.style.marginBottom = '10px';
                 const h3 = document.createElement('h3'); h3.textContent = `--- TURN ${turn.turnNumber} ---`; h3.style.color = '#e57373'; h3.style.margin = '0 0 5px 0'; h3.style.fontSize = '1.1em'; turnDiv.appendChild(h3);
                 const branchesDiv = document.createElement('div'); branchesDiv.style.display = 'flex'; branchesDiv.style.gap = '10px';
                 turn.branches.forEach((branch, index) => {
                     const branchDiv = document.createElement('div'); branchDiv.style.flex = '1'; branchDiv.style.border = '1px solid #444'; branchDiv.style.padding = '5px'; branchDiv.style.borderRadius = '3px';
                     if (currentWorkData.state.isBranchingMode && turn.turnNumber === currentWorkData.state.currentTurn && index === currentWorkData.state.currentBranchIndex) { branchDiv.style.borderColor = '#ff9800'; branchDiv.style.backgroundColor = 'rgba(255, 152, 0, 0.1)'; } else { branchDiv.style.borderColor = '#444'; branchDiv.style.backgroundColor = 'transparent'; }
                     if (turn.branches.length > 1) { const branchLabel = document.createElement('div'); branchLabel.textContent = `åˆ†å² ${String.fromCharCode(65 + index)}`; branchLabel.style.fontWeight = 'bold'; branchLabel.style.fontSize = '0.9em'; branchLabel.style.color = '#aaa'; branchDiv.appendChild(branchLabel); }
                     const ul = document.createElement('ul'); ul.style.margin = '0'; ul.style.paddingLeft = '15px'; ul.style.fontSize = '0.95em';
                     branch.actions.forEach(action => { const li = document.createElement('li'); li.textContent = action; li.style.listStyle = 'square'; ul.appendChild(li); });
                     branchDiv.appendChild(ul);
                     if (branch.memo) { const memoP = document.createElement('p'); memoP.textContent = `ğŸ“ ${branch.memo}`; memoP.style.fontSize = '0.85em'; memoP.style.color = '#ccc'; memoP.style.marginTop = '5px'; memoP.style.whiteSpace = 'pre-wrap'; branchDiv.appendChild(memoP); }
                     branchesDiv.appendChild(branchDiv);
                 });
                 turnDiv.appendChild(branchesDiv); newHistoryView.appendChild(turnDiv);
             });
             newHistoryView.scrollTop = newHistoryView.scrollHeight;
        }
       function selectCharacter(index, skipSave = false) {
           // æ™®é€šã®ãƒ¦ãƒ¼ã‚¶æ“ä½œã¯ undo å¯¾è±¡ã«ã™ã‚‹ãŒã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‹ã‚‰ã®å‘¼ã³å‡ºã—ã§ã¯ skip å¯èƒ½
           if (!skipSave) saveStateForUndo();
           currentWorkData.state.selectedCharIndex = index; document.querySelectorAll('.char-btn').forEach(btn => btn.classList.remove('selected'));
           const selectedBtn = document.querySelector(`.char-btn[data-char-index="${index}"]`); if (selectedBtn) { selectedBtn.classList.add('selected'); }
           saveCurrentWork();
       }
        // â˜…V25->V27: ç”»é¢é·ç§»é–¢æ•° (V21/V17ç›¸å½“)
        function goToMovePhase() {
             const setup = currentWorkData.setup;
             summonButtonsContainer.innerHTML = ''; setup.summons.forEach(summonName => { if (summonName) { const btn = document.createElement('button'); btn.className = 'summon-btn btn'; btn.textContent = summonName; btn.addEventListener('click', () => { saveStateForUndo(); logAction(`[å¬å–š: ${summonName}]`); }); summonButtonsContainer.appendChild(btn); } });
             charSelectContainer.innerHTML = ''; const totalChars = 4 + setup.subCount;
             for (let i = 0; i < totalChars; i++) { let charName = setup.characters[i]; if (!charName) { if (i === 0) charName = "ä¸»äººå…¬"; else if (i < 4) charName = `ã‚­ãƒ£ãƒ©${i + 1}`; else charName = `ã‚µãƒ–${i - 3}`; } const btn = document.createElement('button'); btn.className = 'char-btn'; btn.textContent = charName; btn.dataset.charIndex = i; if (i >= 4) btn.classList.add('is-sub'); btn.addEventListener('click', () => selectCharacter(i)); charSelectContainer.appendChild(btn); }
             setupPhase.style.display = 'none'; movePhase.style.display = 'block'; movePhase.classList.remove('playback-mode');
             loadStateDataToDOM(); selectCharacter(currentWorkData.state.selectedCharIndex, true);
             console.log("Navigated to Move Phase (V27)"); // Debug log
        }
        function goToSetupPhase() {
            movePhase.style.display = 'none'; setupPhase.style.display = 'block';
            loadSetupDataToDOM(); loadSlotNames();
             console.log("Navigated to Setup Phase (V27)"); // Debug log
        }
        // V26: åˆ†å²UIæ›´æ–°
        function updateBranchingUI() {
             const state = currentWorkData.state; const currentTurnData = getCurrentTurnData(false);
             if (state.isBranchingMode && currentTurnData) {
                 branchingControls.style.display = 'block'; startBranchingBtn.style.display = 'none';
                 const branchChar = String.fromCharCode(65 + state.currentBranchIndex);
                 branchingStatus.textContent = `åˆ†å² ${branchChar} å…¥åŠ›ä¸­ (${state.currentBranchIndex + 1}/${state.totalBranchesInTurn})`;
                 nextBranchBtn.disabled = (state.currentBranchIndex >= state.totalBranchesInTurn - 1);
                 branchingSelector.innerHTML = '';
                 for (let i = 0; i < state.totalBranchesInTurn; i++) {
                     const btn = document.createElement('button'); btn.textContent = `åˆ†å² ${String.fromCharCode(65 + i)}`;
                     btn.className = 'branch-select-btn'; if (i === state.currentBranchIndex) { btn.classList.add('active-branch-edit'); }
                    btn.onclick = ((index) => () => { saveStateForUndo(); saveCurrentWork(); state.currentBranchIndex = index; const turnData = getCurrentTurnData(false); turnMemoInput.value = turnData?.branches[index]?.memo || ''; updateBranchingUI(); renderHistoryView(); saveCurrentWork(); })(i); // å­˜åœ¨ãƒã‚§ãƒƒã‚¯è¿½åŠ 
                     branchingSelector.appendChild(btn);
                 }
             } else { branchingControls.style.display = 'none'; startBranchingBtn.style.display = 'block'; }
        }
        function finishBranchingMode() {
             currentWorkData.state.isBranchingMode = false; currentWorkData.state.currentBranchIndex = 0;
             updateBranchingUI(); renderHistoryView();
             // V24: ã‚¿ãƒ¼ãƒ³ã‚’é€²ã‚ãªã„
        }
        // ã‚¿ãƒ¼ãƒ³ã‚’é€²ã‚ã‚‹ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
        function advanceTurn() {
            const state = currentWorkData.state;
            state.currentTurn++;
            turnCounter.textContent = `TURN ${state.currentTurn}`;
            // ensure next turn exists
            getCurrentTurnData();
            renderHistoryView();
            const nextTurnData = getCurrentTurnData(false);
            turnMemoInput.value = nextTurnData?.branches[0]?.memo || '';
            saveCurrentWork();
        }
        // V23: å†ç”Ÿãƒ¢ãƒ¼ãƒ‰ç”¨ buildPlaybackView
        function buildPlaybackView() {
            playbackArea.innerHTML = ''; const turnsData = currentWorkData.state.turns; totalPlaybackTurns = turnsData.length;
            if (totalPlaybackTurns === 0) { playbackArea.innerHTML = '<p>å±¥æ­´ãªã—</p>'; totalPlaybackTurns = 1; currentPlaybackTurn = 1; updatePlaybackHighlight(); return; }
            turnsData.forEach(turn => { const turnNumber = turn.turnNumber; const turnDiv = document.createElement('div'); turnDiv.className = 'playback-turn'; turnDiv.dataset.turn = turnNumber; const h3 = document.createElement('h3'); h3.textContent = `--- TURN ${turnNumber} ---`; turnDiv.appendChild(h3); if (turn.branches.length > 1) { turnDiv.classList.add('has-branches'); const branchesContainer = document.createElement('div'); branchesContainer.className = 'playback-branches-container'; turn.branches.forEach((branch, index) => { const branchDiv = document.createElement('div'); branchDiv.className = 'playback-branch'; const branchLabel = document.createElement('h4'); branchLabel.textContent = `åˆ†å² ${String.fromCharCode(65 + index)}`; branchDiv.appendChild(branchLabel); if (branch.memo) { const memoDiv = document.createElement('div'); memoDiv.className = 'playback-memo'; memoDiv.textContent = branch.memo; branchDiv.appendChild(memoDiv); } const ul = document.createElement('ul'); branch.actions.forEach(action => { const li = document.createElement('li'); li.textContent = action; ul.appendChild(li); }); branchDiv.appendChild(ul); branchesContainer.appendChild(branchDiv); }); turnDiv.appendChild(branchesContainer); } else { const branch = turn.branches[0]; if (branch.memo) { const memoDiv = document.createElement('div'); memoDiv.className = 'playback-memo'; memoDiv.textContent = branch.memo; turnDiv.appendChild(memoDiv); } const ul = document.createElement('ul'); branch.actions.forEach(action => { const li = document.createElement('li'); li.textContent = action; ul.appendChild(li); }); turnDiv.appendChild(ul); } playbackArea.appendChild(turnDiv); });
            currentPlaybackTurn = Math.min(currentWorkData.state.currentTurn, totalPlaybackTurns); if (currentPlaybackTurn < 1) currentPlaybackTurn = 1; updatePlaybackHighlight();
        }
        // V23: å†ç”Ÿãƒ¢ãƒ¼ãƒ‰ç”¨ updatePlaybackHighlight
        function updatePlaybackHighlight() {
            playbackNavCenter.textContent = `TURN ${currentPlaybackTurn} / ${totalPlaybackTurns}`; playbackPrevBtn.disabled = (currentPlaybackTurn <= 1); playbackNextBtn.disabled = (currentPlaybackTurn >= totalPlaybackTurns);
            document.querySelectorAll('.playback-turn').forEach(div => { if (parseInt(div.dataset.turn, 10) === currentPlaybackTurn) { div.classList.add('active-turn'); div.scrollIntoView({ behavior: 'smooth', block: 'nearest' }); } else { div.classList.remove('active-turn'); } });
        }

        // --- åˆæœŸåŒ–å‡¦ç† ---
        function initialize() {
            console.log("Initializing V27..."); // Debug log
            loadCurrentWork();
            loadSlotNames();
            goToSetupPhase(); // å¿…ãšç·¨æˆç”»é¢ã‹ã‚‰é–‹å§‹
            // duplicate forwarding removed; buttons are the real controls in the history area
            console.log("Initialization complete."); // Debug log
        }
        initialize();

    </script>
<script src='https://storage.ko-fi.com/cdn/scripts/overlay-widget.js'></script>
<script>
  kofiWidgetOverlay.draw('alt4l', { type: 'floating-chat', 'floating-chat.donateButton.text': 'Support me', 'floating-chat.donateButton.background-color': '#794bc4', 'floating-chat.donateButton.text-color': '#fff' });
</script>
</body>
</html>