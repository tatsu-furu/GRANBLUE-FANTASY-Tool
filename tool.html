<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>グラブル ムーブ表作成ツール</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
</head>
<body>

    <div class="container">
        <h1>グラブル ムーブ表作成ツール</h1>

        {/* --- フェーズ1 (HTML変更なし) --- */}
        <div id="setup-phase" style="display: block;">
            {/* ... V19と同じ ... */}
        </div>

        {/* --- フェーズ2 (HTML変更なし) --- */}
        <div id="move-phase" style="display: none;">
             {/* ... V19と同じ ... */}
        </div>
    </div>

    {/* ===== 修正点 (JavaScriptロジック修正) ===== */}
    <script>
        // --- 定数・変数 (変更なし) ---
        const STORAGE_KEY_SLOTS = 'gbfMoveMakerV5_slots';
        const STORAGE_KEY_PREFIX = 'gbfMoveMakerV5_slot_';
        const STORAGE_KEY_CURRENT = 'gbfMoveMakerV5_currentWork';
        const MAX_IMAGE_WIDTH = 1200;
        const IMAGE_QUALITY = 0.7;
        const getDefaultWorkData = () => ({ /* ... V19と同じ ... */ });
        let currentWorkData = getDefaultWorkData();
        let savedSlotNames = [];
        let currentPlaybackTurn = 1;
        let totalPlaybackTurns = 1;

        // --- DOM要素の取得 (変更なし) ---
        const setupPhase = document.getElementById('setup-phase');
        const movePhase = document.getElementById('move-phase');
        // ... (他の要素取得もV19と同じ)

        // --- データ保存/ロード関数 (変更なし) ---
        function saveCurrentWork() { /* ... V19と同じ ... */ }
        function loadCurrentWork() { /* ... V19と同じ ... */ }
        function loadSlotNames() { /* ... V19と同じ ... */ }
        function saveSlotNames() { /* ... V19と同じ ... */ }
        function loadSetupDataToDOM() { /* ... V19と同じ ... */ }
        function loadStateDataToDOM() { /* ... V19と同じ ... */ }
        function toggleExtraSubInputs(count) { /* ... V19と同じ ... */ }

        // --- イベントリスナー ---
        setupCompleteBtn.addEventListener('click', () => { saveCurrentWork(); goToMovePhase(); });
        charInputs.forEach(input => input.addEventListener('input', saveCurrentWork));
        summonInputs.forEach(input => input.addEventListener('input', saveCurrentWork));
        subMemberCountSelect.addEventListener('change', (e) => { toggleExtraSubInputs(parseInt(e.target.value, 10)); saveCurrentWork(); });
        turnMemoInput.addEventListener('input', () => { currentWorkData.state.turnMemos[currentWorkData.state.currentTurn] = turnMemoInput.value; saveCurrentWork(); });
        saveBtn.addEventListener('click', () => { /* ... V19と同じ ... */ });
        loadBtn.addEventListener('click', () => { /* ... V19と同じ ... */ });
        deleteBtn.addEventListener('click', () => { /* ... V19と同じ ... */ });
        actionButtons.forEach(btn => { /* ... V19と同じアクションボタンリスナー ... */ });
        moveResetBtn.addEventListener('click', () => { /* ... V19と同じ ... */ });
        backToSetupBtn.addEventListener('click', () => { saveCurrentWork(); goToSetupPhase(); });
        clearAllDataBtn.addEventListener('click', () => { /* ... V19と同じ ... */ });
        copyHistoryBtn.addEventListener('click', () => { /* ... V19と同じ ... */ });
        exportBtn.addEventListener('click', () => { /* ... V19と同じ ... */ });
        importFileInput.addEventListener('change', (event) => { /* ... V19と同じ ... */ });
        resetSetupBtn.addEventListener('click', () => { /* ... V19と同じ ... */ });
        overwriteSaveBtn.addEventListener('click', () => { /* ... V19と同じ ... */ });
        undoLastActionBtn.addEventListener('click', () => { /* ... V19と同じ ... */ });
        overallMemoInput.addEventListener('input', saveCurrentWork);
        weaponImageInput.addEventListener('change', handleImageUpload);
        clearWeaponImageBtn.addEventListener('click', () => { /* ... V19と同じ ... */ });
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => { weaponImageUploadArea.addEventListener(eventName, preventDefaults, false); });
        ['dragenter', 'dragover'].forEach(eventName => { weaponImageUploadArea.addEventListener(eventName, () => weaponImageUploadArea.classList.add('highlight'), false); });
        ['dragleave', 'drop'].forEach(eventName => { weaponImageUploadArea.addEventListener(eventName, () => weaponImageUploadArea.classList.remove('highlight'), false); });
        weaponImageUploadArea.addEventListener('drop', handleImageDrop, false);
        gotoPlaybackBtn.addEventListener('click', () => { saveCurrentWork(); movePhase.classList.add('playback-mode'); buildPlaybackView(); });
        backToEditBtn.addEventListener('click', () => { movePhase.classList.remove('playback-mode'); loadStateDataToDOM(); });
        playbackNextBtn.addEventListener('click', () => { /* ... V19と同じ ... */ });
        playbackPrevBtn.addEventListener('click', () => { /* ... V19と同じ ... */ });
        savePlaybackImageBtn.addEventListener('click', async () => { /* ... V19と同じ ... */ });

        // V19: ペーストイベントリスナーを修正
        document.addEventListener('paste', handlePaste);
        // V19: ペーストボタンのリスナーを追加
        pasteImageBtn.addEventListener('click', handlePasteButtonClick);

        function preventDefaults(e) { e.preventDefault(); e.stopPropagation(); }
        function handleImageDrop(e) { /* ... V12と同じ ... */ }
        function handleImageUpload(event) { /* ... V12と同じ ... */ }

        // V19/V20: ペースト処理関数を修正
        function handlePaste(event) {
            const targetTagName = event.target.tagName.toLowerCase();
            if (targetTagName === 'input' || targetTagName === 'textarea') { return; }
            const items = event.clipboardData?.items;
            if (!items) return;
            processClipboardItems(items, event);
        }

        async function handlePasteButtonClick() {
            try {
                // HTTPS接続が必要な場合が多い
                const permission = await navigator.permissions.query({ name: 'clipboard-read' });
                if (permission.state === 'denied') {
                    alert('クリップボードへのアクセスが拒否されています。ブラウザの設定を確認してください。');
                    return;
                }
                const clipboardItems = await navigator.clipboard.read();
                processClipboardItems(clipboardItems);
            } catch (err) {
                console.error('クリップボードの読み取り/処理に失敗:', err);
                 alert(`クリップボードからの画像ペーストに失敗しました。\n(${err.name}: ${err.message})\nHTTPS接続が必要な場合があります。`);
            }
        }

        async function processClipboardItems(items, event = null) {
            for (let i = 0; i < items.length; i++) {
                const item = items[i];
                // Blobを取得できるか試す (read APIの場合)
                const imageTypes = item.types?.filter(type => type.startsWith("image/"));
                if (imageTypes?.length > 0) {
                     try {
                         const blob = await item.getType(imageTypes[0]);
                         if (blob) {
                             handleBlobAsFile(blob, event);
                             return; // 最初の画像で終了
                         }
                     } catch (err) {
                         console.error("item.getType() でエラー:", err);
                         // getAsFileを試す (Ctrl+Vの場合)
                     }
                }
                // getAsFileを試す (Ctrl+Vの場合)
                if (typeof item.getAsFile === 'function' && item.type.startsWith('image/')) {
                    const blob = item.getAsFile();
                    if (blob) {
                         handleBlobAsFile(blob, event);
                         return; // 最初の画像で終了
                    }
                }
            }
             // 画像が見つからなかった場合 (ボタンクリック時のみフィードバック)
             if (!event) { // eventがnullならボタンクリック由来
                 alert('クリップボードに画像が見つかりませんでした。');
             }
        }

        function handleBlobAsFile(blob, event = null) { /* ... V19と同じ ... */ }

        // --- 画像処理・プレビュー更新関数 (V12と同じ) ---
        function handleImageFile(file) { /* ... V12と同じ ... */ }
        function updateImagePreview(base64String) { /* ... V12と同じ ... */ }

        // --- 内部関数 ---
        function logToHistory(text) { /* ... V16と同じ ... */ }
        function selectCharacter(index) { /* ... V16と同じ ... */ }

        // ★V20: 画面遷移関数をV17相当に戻す
        function goToMovePhase() {
             const setup = currentWorkData.setup;
             summonButtonsContainer.innerHTML = '';
             setup.summons.forEach(summonName => {
                 if (summonName) {
                     const btn = document.createElement('button'); btn.className = 'summon-btn btn';
                     btn.textContent = summonName; btn.addEventListener('click', () => { logToHistory(`[召喚: ${summonName}]`); });
                     summonButtonsContainer.appendChild(btn);
                 }
             });
             charSelectContainer.innerHTML = '';
             const totalChars = 4 + setup.subCount;
             for (let i = 0; i < totalChars; i++) {
                 let charName = setup.characters[i]; if (!charName) { if (i === 0) charName = "主人公"; else if (i < 4) charName = `キャラ${i + 1}`; else charName = `サブ${i - 3}`; }
                 const btn = document.createElement('button'); btn.className = 'char-btn'; btn.textContent = charName;
                 btn.dataset.charIndex = i; if (i >= 4) btn.classList.add('is-sub');
                 btn.addEventListener('click', () => selectCharacter(i)); charSelectContainer.appendChild(btn);
             }
             // 表示切り替え
             setupPhase.style.display = 'none';
             movePhase.style.display = 'block';
             movePhase.classList.remove('playback-mode');
             // 状態をロードして表示
             loadStateDataToDOM();
             selectCharacter(currentWorkData.state.selectedCharIndex); // 選択キャラも復元
        }

        function goToSetupPhase() {
            // 表示切り替え
            movePhase.style.display = 'none';
            setupPhase.style.display = 'block';
            // 状態をロードして表示
            loadSetupDataToDOM();
            loadSlotNames();
        }

        function buildPlaybackView() { /* ... V15と同じ ... */ }
        function updatePlaybackHighlight() { /* ... V15と同じ ... */ }

        // --- 初期化処理 ---
        function initialize() {
            loadCurrentWork(); // まずデータをロード
            loadSlotNames();   // スロットリストもロード
            goToSetupPhase(); // ★V20: 必ず編成画面から開始
        }

        initialize();

    </script>
<script src='https://storage.ko-fi.com/cdn/scripts/overlay-widget.js'></script>
<script>
  kofiWidgetOverlay.draw('alt4l', {
    'type': 'floating-chat',
    'floating-chat.donateButton.text': 'Support me',
    'floating-chat.donateButton.background-color': '#794bc4',
    'floating-chat.donateButton.text-color': '#fff'
  });
</script>
</body>
</html>